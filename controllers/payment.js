const axios = require('axios');
const Order = require('../models/order');
const emailService = require('../utils/emailService');
const emailSender = require('../utils/emailSender');
const DTE = require('../models/dte');
const DTEGenerator = require('../utils/dteGenerator');
const Customer = require('../models/customer');

// Transbank Production Configuration
const TBK_COMMERCE_CODE = process.env.TBK_COMMERCE_CODE || '597052958374';
const TBK_API_KEY = process.env.TBK_API_KEY || 'c5d59ef5-514c-4792-8f30-b2b0089bf0ea';
const TBK_BASE_URL = process.env.TBK_BASE_URL || 'https://webpay3g.transbank.cl';
const TBK_ENDPOINT = '/rswebpaytransaction/api/webpay/v1.2';

// Helper function to make Transbank API requests
async function transbankRequest(method, endpoint, data = null) {
  const config = {
    method,
    url: `${TBK_BASE_URL}${TBK_ENDPOINT}${endpoint}`,
    headers: {
      'Tbk-Api-Key-Id': TBK_COMMERCE_CODE,
      'Tbk-Api-Key-Secret': TBK_API_KEY,
      'Content-Type': 'application/json'
    }
  };

  if (data) {
    config.data = data;
  }

  return axios(config);
}

// Helper function to generate DTE (auto or manual)
async function generateDTE(order, tipoDTE = 39) {
  try {
    const emisorData = {
      rut: process.env.COMPANY_RUT || '77226199-3',
      razonSocial: process.env.COMPANY_NAME || 'Siriza Agaria S.A.',
      giro: process.env.COMPANY_GIRO || 'Comercio',
      acteco: [620200],
      direccion: process.env.COMPANY_ADDRESS || 'Av. Principal 123',
      comuna: process.env.COMPANY_COMMUNE || 'Santiago',
      ciudad: process.env.COMPANY_CITY || 'Santiago',
      email: process.env.COMPANY_EMAIL || 'contacto@sirizagaria.com'
    };

    const generator = new DTEGenerator(emisorData);
    let result;

    const dteData = {
      rutReceptor: order.customer.rut || '0-0',
      razonSocialReceptor: order.customer.nombre,
      giroReceptor: 'Consumidor Final',
      dirReceptor: order.customer.direccion,
      cmnaReceptor: order.customer.comuna,
      ciudadReceptor: order.customer.region,
      correoReceptor: order.customer.email,
      mntNeto: order.subtotal,
      tasaIVA: 19,
      iva: Math.round(order.subtotal * 0.19),
      mntTotal: order.total,
      items: order.items.map(item => ({
        nmbItem: item.product,
        qtyItem: item.quantity,
        prcItem: item.unit_price,
        montoItem: item.quantity * item.unit_price
      }))
    };

    if (tipoDTE === 33) {
      result = generator.createFacturaElectronica(dteData);
    } else {
      result = generator.createBoletaElectronica(dteData);
    }

    const { uuid, dte } = result;

    let customer = await Customer.findOne({
      $or: [
        { email: order.customer.email },
        { name: order.customer.nombre }
      ]
    });

    const dteDocument = new DTE({
      uuid,
      tipoDTE,
      status: 'pending',
      rutEmisor: dte.DTE.Encabezado.Emisor.RUTEmisor.replace(/\D/g, ''),
      rutReceptor: dte.DTE.Encabezado.Receptor.RUTRecep.replace(/\D/g, ''),
      customerId: customer?._id,
      fechaEmision: new Date(dte.DTE.Encabezado.IdDoc.FchEmis),
      mntNeto: dte.DTE.Encabezado.Totales.MntNeto,
      tasaIVA: dte.DTE.Encabezado.Totales.TasaIVA,
      iva: dte.DTE.Encabezado.Totales.IVA,
      mntTotal: dte.DTE.Encabezado.Totales.MntTotal,
      detalle: dte.DTE.Detalle,
      dteJson: dte.DTE,
      createdBy: 'system-auto'
    });

    await dteDocument.save();

    order.dte_uuid = uuid;
    order.dte_type = tipoDTE === 33 ? 'factura' : 'boleta';
    await order.save();

    return {
      uuid,
      tipoDTE,
      status: 'pending'
    };
  } catch (error) {
    console.error('Error generating DTE:', error.message);
    return null;
  }
}

// Helper function to auto-generate DTE based on payment method and source
async function autoGenerateDTE(order, source = 'manual') {
  try {
    const shouldAutoGenerate = 
      order.payment_method === 'transferencia' && source === 'website';
    
    if (!shouldAutoGenerate) {
      return null;
    }

    return await generateDTE(order, 39);
  } catch (error) {
    console.error('Error auto-generating DTE:', error.message);
    return null;
  }
}

// Helper function to generate manual DTE with selected type
async function generateManualDTE(order, dteType) {
  try {
    const tipoDTE = dteType === 'factura' ? 33 : 39;
    return await generateDTE(order, tipoDTE);
  } catch (error) {
    console.error('Error generating manual DTE:', error.message);
    return null;
  }
}

// Create a new transaction
exports.createTransaction = async (req, res) => {
  try {
    const { 
      nombre, email, telefono, region, comuna, direccion, notas,
      cantidad, payment_method, subtotal, shipping_cost, total, return_url
    } = req.body;

    // Validate required fields
    if (!nombre || !email || !telefono || !region || !comuna || !direccion) {
      return res.status(400).json({
        success: false,
        error: 'Faltan campos obligatorios del cliente'
      });
    }

    if (!total || total < 100) {
      return res.status(400).json({
        success: false,
        error: 'El monto debe ser al menos $100 CLP'
      });
    }

    // Generate order identifiers
    const buy_order = Order.generateBuyOrder();
    const session_id = Order.generateSessionId();

    // Create order in database
    const order = new Order({
      buy_order,
      session_id,
      customer: {
        nombre,
        email,
        telefono,
        region,
        comuna,
        direccion,
        notas
      },
      items: [{
        product: 'La Nueva Violencia Moderna',
        quantity: parseInt(cantidad) || 1,
        unit_price: 19000
      }],
      subtotal: parseInt(subtotal),
      shipping_cost: parseInt(shipping_cost) || 0,
      total: parseInt(total),
      payment_method: payment_method || 'webpay',
      status: 'initiated'
    });

    await order.save();

    // If payment method is transferencia, just return order info
    if (payment_method === 'transferencia') {
      order.status = 'pending_payment';
      await order.save();
      
      return res.json({
        success: true,
        payment_method: 'transferencia',
        order_id: buy_order,
        message: 'Orden creada. Por favor realiza la transferencia.'
      });
    }

    // Create Transbank transaction
    const tbkPayload = {
      buy_order,
      session_id,
      amount: parseInt(total),
      return_url: return_url || `${process.env.API_URL || `${req.protocol}://${req.get('host')}`}/api/payment/return`
    };

    console.log('Creating Transbank transaction:', tbkPayload);

    const tbkResponse = await transbankRequest('post', '/transactions', tbkPayload);

    // Update order with Transbank data
    order.transbank_token = tbkResponse.data.token;
    order.transbank_url = tbkResponse.data.url;
    order.status = 'pending_payment';
    await order.save();

    // Return redirect URL
    const redirectUrl = `${tbkResponse.data.url}?token_ws=${tbkResponse.data.token}`;

    res.json({
      success: true,
      redirect_url: redirectUrl,
      token: tbkResponse.data.token,
      order_id: buy_order
    });

  } catch (error) {
    console.error('Error creating transaction:', error.response?.data || error.message);
    res.status(500).json({
      success: false,
      error: 'Error al crear la transacción',
      details: error.response?.data || error.message
    });
  }
};

// Confirm transaction (called by Transbank redirect)
exports.confirmTransaction = async (req, res) => {
  try {
    // Transbank sends token_ws via POST or GET
    const token_ws = req.body.token_ws || req.query.token_ws;
    const TBK_TOKEN = req.body.TBK_TOKEN || req.query.TBK_TOKEN;
    const TBK_ORDEN_COMPRA = req.body.TBK_ORDEN_COMPRA || req.query.TBK_ORDEN_COMPRA;
    const TBK_ID_SESION = req.body.TBK_ID_SESION || req.query.TBK_ID_SESION;

    // Check if user cancelled payment
    if (TBK_TOKEN && !token_ws) {
      // User cancelled at Webpay
      const order = await Order.findOne({ buy_order: TBK_ORDEN_COMPRA });
      if (order) {
        order.status = 'cancelled';
        order.cancelled_at = new Date();
        await order.save();
      }
      
      // Redirect to frontend with cancelled status
      const frontendUrl = process.env.FRONTEND_URL || 'https://sirizagaria.com';
      return res.redirect(`${frontendUrl}/pago-resultado?status=cancelled&order=${TBK_ORDEN_COMPRA}`);
    }

    if (!token_ws) {
      return res.status(400).json({
        success: false,
        error: 'Token no proporcionado'
      });
    }

    // Find order by token
    const order = await Order.findOne({ transbank_token: token_ws });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    // Confirm transaction with Transbank
    console.log('Confirming transaction with token:', token_ws);
    const tbkResponse = await transbankRequest('put', `/transactions/${token_ws}`, {});

    const paymentData = tbkResponse.data;
    console.log('Transbank confirmation response:', paymentData);

    // Update order with transaction data
    order.transaction_data = {
      vci: paymentData.vci,
      authorization_code: paymentData.authorization_code,
      payment_type_code: paymentData.payment_type_code,
      response_code: paymentData.response_code,
      installments_number: paymentData.installments_number,
      card_last4: paymentData.card_detail?.card_number,
      accounting_date: paymentData.accounting_date,
      transaction_date: paymentData.transaction_date
    };

    // Check if payment was successful
    if (paymentData.response_code === 0 && paymentData.status === 'AUTHORIZED') {
      order.status = 'confirmed';
      order.confirmed_at = new Date();
      await order.save();

      // Redirect to success page
      const frontendUrl = process.env.FRONTEND_URL || 'https://sirizagaria.com';
      return res.redirect(`${frontendUrl}/pago-resultado?status=success&order=${order.buy_order}&auth=${paymentData.authorization_code}`);
    } else {
      order.status = 'failed';
      await order.save();

      // Redirect to failure page
      const frontendUrl = process.env.FRONTEND_URL || 'https://sirizagaria.com';
      return res.redirect(`${frontendUrl}/pago-resultado?status=failed&order=${order.buy_order}&code=${paymentData.response_code}`);
    }

  } catch (error) {
    console.error('Error confirming transaction:', error.response?.data || error.message);
    
    const frontendUrl = process.env.FRONTEND_URL || 'https://sirizagaria.com';
    return res.redirect(`${frontendUrl}/pago-resultado?status=error&message=${encodeURIComponent(error.message)}`);
  }
};

// Get transaction status
exports.getTransactionStatus = async (req, res) => {
  try {
    const { order_id } = req.params;

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    // If there's a token, query Transbank for latest status
    if (order.transbank_token && order.status === 'pending_payment') {
      try {
        const tbkResponse = await transbankRequest('get', `/transactions/${order.transbank_token}`);
        
        return res.json({
          success: true,
          order: {
            order_id: order.buy_order,
            status: order.status,
            total: order.total,
            created_at: order.created_at
          },
          transbank_status: tbkResponse.data
        });
      } catch (tbkError) {
        // Token might be expired, just return order status
      }
    }

    res.json({
      success: true,
      order: {
        order_id: order.buy_order,
        status: order.status,
        total: order.total,
        customer_email: order.customer.email,
        created_at: order.created_at,
        confirmed_at: order.confirmed_at,
        transaction_data: order.status === 'confirmed' ? {
          authorization_code: order.transaction_data?.authorization_code,
          card_last4: order.transaction_data?.card_last4
        } : null
      }
    });

  } catch (error) {
    console.error('Error getting transaction status:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al obtener estado de la transacción'
    });
  }
};

// Refund transaction
exports.refundTransaction = async (req, res) => {
  try {
    const { order_id } = req.params;
    const { amount } = req.body;

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    if (order.status !== 'confirmed') {
      return res.status(400).json({
        success: false,
        error: 'Solo se pueden reembolsar órdenes confirmadas'
      });
    }

    if (!order.transbank_token) {
      return res.status(400).json({
        success: false,
        error: 'No hay token de Transbank para esta orden'
      });
    }

    const refundAmount = amount || order.total;

    const tbkResponse = await transbankRequest('post', `/transactions/${order.transbank_token}/refunds`, {
      amount: parseInt(refundAmount)
    });

    order.status = 'refunded';
    await order.save();

    res.json({
      success: true,
      message: 'Reembolso procesado exitosamente',
      data: tbkResponse.data
    });

  } catch (error) {
    console.error('Error processing refund:', error.response?.data || error.message);
    res.status(500).json({
      success: false,
      error: 'Error al procesar el reembolso',
      details: error.response?.data || error.message
    });
  }
};

// Retry a failed/cancelled payment
exports.retryPayment = async (req, res) => {
  try {
    const { order_id } = req.params;
    const { return_url } = req.body;

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    // Only allow retry for failed or cancelled orders
    if (!['failed', 'cancelled', 'initiated'].includes(order.status)) {
      return res.status(400).json({
        success: false,
        error: `No se puede reintentar una orden con estado: ${order.status}`
      });
    }

    // Generate new session_id for retry
    const new_session_id = Order.generateSessionId();

    // Create new Transbank transaction
    const tbkPayload = {
      buy_order: order.buy_order,
      session_id: new_session_id,
      amount: order.total,
      return_url: return_url || `${req.protocol}://${req.get('host')}/api/payment/return`
    };

    console.log('Retrying Transbank transaction:', tbkPayload);

    const tbkResponse = await transbankRequest('post', '/transactions', tbkPayload);

    // Update order with new Transbank data
    order.session_id = new_session_id;
    order.transbank_token = tbkResponse.data.token;
    order.transbank_url = tbkResponse.data.url;
    order.status = 'pending_payment';
    order.updated_at = new Date();
    await order.save();

    // Return new redirect URL
    const redirectUrl = `${tbkResponse.data.url}?token_ws=${tbkResponse.data.token}`;

    res.json({
      success: true,
      redirect_url: redirectUrl,
      token: tbkResponse.data.token,
      order_id: order.buy_order
    });

  } catch (error) {
    console.error('Error retrying payment:', error.response?.data || error.message);
    res.status(500).json({
      success: false,
      error: 'Error al reintentar el pago',
      details: error.response?.data || error.message
    });
  }
};

// Get all orders (admin)
exports.getOrders = async (req, res) => {
  try {
    const { status, page = 1, limit = 20 } = req.query;
    
    const query = {};
    if (status) {
      query.status = status;
    }

    const orders = await Order.find(query)
      .sort({ created_at: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Order.countDocuments(query);

    res.json({
      success: true,
      orders,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('Error getting orders:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al obtener órdenes'
    });
  }
};

// Confirm bank transfer payment (admin)
exports.confirmTransferPayment = async (req, res) => {
  try {
    const { order_id } = req.params;
    const { confirmation_notes, source = 'manual' } = req.body;

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    if (order.payment_method !== 'transferencia') {
      return res.status(400).json({
        success: false,
        error: 'Esta orden no es de transferencia bancaria'
      });
    }

    if (order.status === 'confirmed') {
      return res.status(400).json({
        success: false,
        error: 'Esta orden ya está confirmada'
      });
    }

    order.status = 'confirmed';
    order.confirmed_at = new Date();
    order.transaction_data = {
      ...order.transaction_data,
      confirmation_notes: confirmation_notes || 'Transferencia confirmada manualmente',
      confirmed_by: 'admin'
    };
    await order.save();

    // Deduct stock
    const Book = require('../models/book');
    for (const item of order.items) {
      await Book.findOneAndUpdate(
        { title: item.product },
        { $inc: { stock: -item.quantity, sold: item.quantity } }
      );
    }

    // Auto-generate boleta if payment is from website
    let dteResult = null;
    if (source === 'website') {
      dteResult = await autoGenerateDTE(order, 'website');
    }

    res.json({
      success: true,
      message: 'Pago por transferencia confirmado',
      order: {
        order_id: order.buy_order,
        status: order.status,
        confirmed_at: order.confirmed_at
      },
      dte: dteResult ? {
        uuid: dteResult.uuid,
        tipoDTE: dteResult.tipoDTE,
        status: dteResult.status,
        message: 'Boleta Electrónica auto-generada'
      } : null
    });

  } catch (error) {
    console.error('Error confirming transfer:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al confirmar transferencia'
    });
  }
};

// Update order status (admin)
exports.updateOrderStatus = async (req, res) => {
  try {
    const { order_id } = req.params;
    const { status, notes, tracking_number, dte_type } = req.body;

    const validStatuses = ['initiated', 'pending_payment', 'confirmed', 'cancelled', 'refunded', 'failed', 'shipped', 'delivered'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        error: `Estado inválido. Estados válidos: ${validStatuses.join(', ')}`
      });
    }

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    const previousStatus = order.status;
    order.status = status;
    
    if (status === 'confirmed' && previousStatus !== 'confirmed') {
      order.confirmed_at = new Date();
      
      // Deduct stock on confirmation
      const Book = require('../models/book');
      for (const item of order.items) {
        await Book.findOneAndUpdate(
          { title: item.product },
          { $inc: { stock: -item.quantity, sold: item.quantity } }
        );
      }
    }
    
    if (status === 'cancelled') {
      order.cancelled_at = new Date();
    }

    if (status === 'shipped' && tracking_number) {
      order.tracking_number = tracking_number;
    }

    if (notes) {
      order.transaction_data = {
        ...order.transaction_data,
        admin_notes: notes
      };
    }

    await order.save();

    let dteResult = null;
    
    // Generate DTE if specified and order is confirmed (manual orders only)
    if (status === 'confirmed' && dte_type && order.payment_method === 'transferencia') {
      dteResult = await generateManualDTE(order, dte_type);
    }

    res.json({
      success: true,
      message: `Estado actualizado a: ${status}`,
      order: {
        order_id: order.buy_order,
        status: order.status,
        previous_status: previousStatus,
        tracking_number: order.tracking_number || null
      },
      dte: dteResult ? {
        uuid: dteResult.uuid,
        tipoDTE: dteResult.tipoDTE,
        status: dteResult.status,
        message: `${dteResult.tipoDTE === 33 ? 'Factura' : 'Boleta'} Electrónica generada`
      } : null
    });

  } catch (error) {
    console.error('Error updating order status:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al actualizar estado'
    });
  }
};

// Send confirmation email
exports.sendConfirmationEmail = async (req, res) => {
  try {
    const { order_id } = req.params;
    const { email, template } = req.body;

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    const customerEmail = email || order.customer.email;

    // Check if email service is ready
    if (!emailSender.isReady()) {
      return res.status(503).json({
        success: false,
        error: 'Email service not configured. Check SMTP settings.'
      });
    }

    // Determine which template to use based on order status or explicit template parameter
    let templateName = template;
    let emailResult;

    if (!templateName) {
      if (order.payment_method === 'transferencia' && order.status === 'confirmed') {
        templateName = 'transfer-confirmation';
        emailResult = await emailSender.sendTransferConfirmationEmail(order, customerEmail);
      } else if (order.status === 'shipped') {
        templateName = 'shipping-notification';
        emailResult = await emailSender.sendShippingNotificationEmail(order, customerEmail);
      } else {
        templateName = 'order-confirmation';
        emailResult = await emailSender.sendOrderConfirmationEmail(order, customerEmail);
      }
    } else {
      // Use explicit template
      let emailData;
      let subject;
      
      switch (templateName) {
        case 'transfer-confirmation':
          emailData = emailService.prepareTransferConfirmationData(order);
          subject = 'Transferencia Confirmada - Siriza Agaria';
          break;
        case 'shipping-notification':
          emailData = emailService.prepareShippingNotificationData(order);
          subject = 'Tu Orden ha sido Enviada - Siriza Agaria';
          break;
        case 'order-confirmation':
        default:
          emailData = emailService.prepareOrderConfirmationData(order);
          subject = 'Confirmación de Orden - Siriza Agaria';
          break;
      }

      emailResult = await emailSender.sendTemplateEmail(
        customerEmail,
        subject,
        templateName,
        emailData
      );
    }

    // Check if email was sent successfully
    if (!emailResult.success) {
      return res.status(500).json({
        success: false,
        error: 'Error al enviar email de confirmación',
        details: emailResult.error
      });
    }

    res.json({
      success: true,
      message: 'Email sent successfully',
      email_sent_to: customerEmail,
      order_id: order.buy_order,
      status: order.status,
      template: templateName,
      messageId: emailResult.messageId
    });

  } catch (error) {
    console.error('Error sending confirmation email:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al enviar email de confirmación',
      details: error.message
    });
  }
};

// Upload invoice
exports.uploadInvoice = async (req, res) => {
  try {
    const { buyOrder } = req.params;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No se proporcionó ningún archivo'
      });
    }

    // Verify file is PDF
    if (req.file.mimetype !== 'application/pdf') {
      return res.status(400).json({
        success: false,
        error: 'Solo se aceptan archivos PDF'
      });
    }

    const order = await Order.findOne({ buy_order: buyOrder });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    // Only allow invoice upload for non-Transbank payments
    if (order.payment_method === 'webpay') {
      return res.status(400).json({
        success: false,
        error: 'No se pueden subir facturas para pagos con Webpay'
      });
    }

    // Store invoice path in order
    const invoicePath = `/uploads/invoices/${buyOrder}_${req.file.filename}`;
    order.invoice_url = invoicePath;
    await order.save();

    res.json({
      success: true,
      message: 'Invoice uploaded successfully',
      invoice_url: invoicePath,
      order_id: buyOrder
    });

  } catch (error) {
    console.error('Error uploading invoice:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al subir la factura'
    });
  }
};

// Download invoice
exports.downloadInvoice = async (req, res) => {
  try {
    const { buyOrder } = req.params;

    const order = await Order.findOne({ buy_order: buyOrder });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    if (!order.invoice_url) {
      return res.status(404).json({
        success: false,
        error: 'No hay factura disponible para esta orden'
      });
    }

    // Return the invoice file path
    // The frontend will handle the actual file download
    res.json({
      success: true,
      invoice_url: order.invoice_url,
      order_id: buyOrder
    });

  } catch (error) {
    console.error('Error downloading invoice:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al descargar la factura'
    });
  }
};

// Generate DTE for order (manual selection)
exports.generateDTEForOrder = async (req, res) => {
  try {
    const { order_id } = req.params;
    const { dte_type } = req.body;

    if (!['factura', 'boleta'].includes(dte_type)) {
      return res.status(400).json({
        success: false,
        error: 'Tipo de documento inválido. Use "factura" o "boleta"'
      });
    }

    const order = await Order.findOne({ buy_order: order_id });
    if (!order) {
      return res.status(404).json({
        success: false,
        error: 'Orden no encontrada'
      });
    }

    if (order.status !== 'confirmed') {
      return res.status(400).json({
        success: false,
        error: 'Solo se pueden generar documentos para órdenes confirmadas'
      });
    }

    if (order.dte_uuid) {
      return res.status(400).json({
        success: false,
        error: 'Esta orden ya tiene un documento tributario generado',
        dte: {
          uuid: order.dte_uuid,
          type: order.dte_type
        }
      });
    }

    const dteResult = await generateManualDTE(order, dte_type);

    if (!dteResult) {
      return res.status(500).json({
        success: false,
        error: 'Error al generar el documento tributario'
      });
    }

    res.json({
      success: true,
      message: `${dte_type === 'factura' ? 'Factura' : 'Boleta'} Electrónica generada exitosamente`,
      dte: {
        uuid: dteResult.uuid,
        tipoDTE: dteResult.tipoDTE,
        status: dteResult.status,
        type: dte_type
      }
    });

  } catch (error) {
    console.error('Error generating DTE:', error.message);
    res.status(500).json({
      success: false,
      error: 'Error al generar documento tributario'
    });
  }
};
